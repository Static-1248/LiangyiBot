/**
 * Creepç®¡ç†å™¨ - ç»Ÿä¸€ç®¡ç†æ‰€æœ‰creepçš„ç”Ÿæˆã€åˆ†é…å’Œç›‘æ§
 */
import { SignalEmitter, signal } from '../SignalSystem';
import { memory } from '../MemoryManager';
import { globalConfig } from '../config/GlobalConfig';

export interface CreepAssignment {
    creepName: string;
    role: string;
    targetId?: Id<any>;
    priority: number;
    assignedTime: number;
    status: 'assigned' | 'working' | 'completed' | 'failed';
}

export interface CreepStatistics {
    totalCreeps: number;
    byRole: { [role: string]: number };
    byRoom: { [roomName: string]: number };
    efficiency: { [role: string]: number };
}

export class CreepManager extends SignalEmitter {
    private static instance: CreepManager;
    private assignments: Map<string, CreepAssignment> = new Map();
    private roleQueues: Map<string, string[]> = new Map(); // role -> creep names queue
    
    private constructor() {
        super();
        this.defineSignal('creep_manager.assignment_created');
        this.defineSignal('creep_manager.assignment_completed');
        this.defineSignal('creep_manager.assignment_failed');
        this.defineSignal('creep_manager.creep_idle');
        this.defineSignal('creep_manager.role_shortage');
        this.defineSignal('creep_manager.efficiency_report');
        
        this.autoConnectSignals();
    }

    public static getInstance(): CreepManager {
        if (!CreepManager.instance) {
            CreepManager.instance = new CreepManager();
        }
        return CreepManager.instance;
    }

    /**
     * æ³¨å†Œcreepåˆ°ç®¡ç†å™¨
     */
    public registerCreep(creepName: string, role: string): void {
        if (!this.roleQueues.has(role)) {
            this.roleQueues.set(role, []);
        }
        
        const queue = this.roleQueues.get(role)!;
        if (!queue.includes(creepName)) {
            queue.push(creepName);
            console.log(`ğŸ“‹ æ³¨å†Œcreep: ${creepName} (${role})`);
        }
    }

    /**
     * ç§»é™¤creepï¼ˆæ­»äº¡æ—¶è°ƒç”¨ï¼‰
     */
    public unregisterCreep(creepName: string): void {
        // ä»æ‰€æœ‰é˜Ÿåˆ—ä¸­ç§»é™¤
        for (const [role, queue] of this.roleQueues) {
            const index = queue.indexOf(creepName);
            if (index !== -1) {
                queue.splice(index, 1);
                console.log(`ğŸ—‘ï¸ ç§»é™¤creep: ${creepName} (${role})`);
            }
        }
        
        // ç§»é™¤ä»»åŠ¡åˆ†é…
        this.assignments.delete(creepName);
    }

    /**
     * åˆ†é…ä»»åŠ¡ç»™creep
     */
    public assignTask(
        creepName: string, 
        role: string, 
        targetId?: Id<any>, 
        priority: number = 1
    ): boolean {
        const creep = Game.creeps[creepName];
        if (!creep) return false;

        const assignment: CreepAssignment = {
            creepName,
            role,
            targetId,
            priority,
            assignedTime: Game.time,
            status: 'assigned'
        };

        this.assignments.set(creepName, assignment);
        
        this.emitSignal('creep_manager.assignment_created', {
            assignment,
            creep
        });

        console.log(`ğŸ“‹ åˆ†é…ä»»åŠ¡: ${creepName} -> ${role}${targetId ? ` (ç›®æ ‡: ${targetId})` : ''}`);
        return true;
    }

    /**
     * è·å–æŒ‡å®šè§’è‰²çš„ç©ºé—²creep
     */
    public getIdleCreep(role: string): Creep | null {
        const queue = this.roleQueues.get(role);
        if (!queue) return null;

        for (const creepName of queue) {
            const creep = Game.creeps[creepName];
            if (!creep) continue;

            const assignment = this.assignments.get(creepName);
            if (!assignment || assignment.status === 'completed') {
                return creep;
            }
        }

        return null;
    }

    /**
     * è·å–è§’è‰²æ•°é‡
     */
    public getRoleCount(role: string): number {
        const queue = this.roleQueues.get(role);
        if (!queue) return 0;
        
        return queue.filter(name => Game.creeps[name]).length;
    }

    /**
     * æ£€æŸ¥è§’è‰²çŸ­ç¼º
     */
    public checkRoleShortage(roomName: string): void {
        const roles = ['upgrader', 'builder', 'miner', 'hauler', 'supplier'];
        
        for (const role of roles) {
            const currentCount = this.getRoleCount(role);
            const targetCount = globalConfig.getRoomCreepLimit(roomName, role);
            
            if (currentCount < targetCount) {
                this.emitSignal('creep_manager.role_shortage', {
                    role,
                    currentCount,
                    targetCount,
                    roomName,
                    shortage: targetCount - currentCount
                });
            }
        }
    }

    /**
     * è·å–ç»Ÿè®¡ä¿¡æ¯
     */
    public getStatistics(): CreepStatistics {
        const stats: CreepStatistics = {
            totalCreeps: 0,
            byRole: {},
            byRoom: {},
            efficiency: {}
        };

        for (const creepName in Game.creeps) {
            const creep = Game.creeps[creepName];
            const role = memory.getCreepMemory(creepName).role || 'unknown';
            const roomName = creep.room.name;

            stats.totalCreeps++;
            stats.byRole[role] = (stats.byRole[role] || 0) + 1;
            stats.byRoom[roomName] = (stats.byRoom[roomName] || 0) + 1;
        }

        // è®¡ç®—æ•ˆç‡ï¼ˆç®€åŒ–ç‰ˆæœ¬ï¼‰
        for (const role in stats.byRole) {
            const count = stats.byRole[role];
            const assignments = Array.from(this.assignments.values())
                .filter(a => a.role === role && a.status === 'working').length;
            stats.efficiency[role] = count > 0 ? (assignments / count) * 100 : 0;
        }

        return stats;
    }

    /**
     * å¤„ç†creepç”Ÿæˆå®Œæˆ
     */
    @signal('creep.fully_spawned', 10)
    private onCreepSpawned(data: { creepName: string, role: string }): void {
        this.registerCreep(data.creepName, data.role);
    }

    /**
     * å¤„ç†creepæ­»äº¡
     */
    @signal('creep.died', 10)
    private onCreepDied(data: { creep: Creep, role: string }): void {
        this.unregisterCreep(data.creep.name);
    }

    /**
     * ç›‘å¬å»ºé€ ä»»åŠ¡éœ€æ±‚
     */
    @signal('building.construction_task_needed', 15)
    private onConstructionTaskNeeded(data: { target: ConstructionSite, priority: number }): void {
        const builder = this.getIdleCreep('builder');
        if (builder) {
            this.assignTask(builder.name, 'builder', data.target.id, data.priority);
        }
    }

    /**
     * ç›‘å¬ä¿®ç†ä»»åŠ¡éœ€æ±‚
     */
    @signal('building.repair_task_needed', 15)
    private onRepairTaskNeeded(data: { target: Structure, priority: number }): void {
        const builder = this.getIdleCreep('builder');
        if (builder) {
            this.assignTask(builder.name, 'repair', data.target.id, data.priority);
        }
    }

    /**
     * ç›‘å¬æ¬è¿ä»»åŠ¡éœ€æ±‚
     */
    @signal('hauler.task_needed', 15)
    private onHaulerTaskNeeded(data: { from: Structure, to: Structure, resourceType: ResourceConstant, priority: number }): void {
        const hauler = this.getIdleCreep('hauler');
        if (hauler) {
            this.assignTask(hauler.name, 'hauler', data.from.id, data.priority);
        }
    }

    /**
     * è¿è¡Œç®¡ç†å™¨é€»è¾‘
     */
    public run(): void {
        // æ¸…ç†æ— æ•ˆçš„creepå¼•ç”¨
        for (const [role, queue] of this.roleQueues) {
            const validCreeps = queue.filter(name => Game.creeps[name]);
            this.roleQueues.set(role, validCreeps);
        }

        // æ£€æŸ¥è§’è‰²çŸ­ç¼º
        for (const roomName in Game.rooms) {
            const room = Game.rooms[roomName];
            if (room.controller && room.controller.my) {
                this.checkRoleShortage(roomName);
            }
        }

        // æ•ˆç‡æŠ¥å‘Š
        if (Game.time % 100 === 0) {
            const stats = this.getStatistics();
            this.emitSignal('creep_manager.efficiency_report', { stats });
            
            console.log(`ğŸ“Š Creepç»Ÿè®¡æŠ¥å‘Š:`);
            console.log(`æ€»æ•°: ${stats.totalCreeps}`);
            console.log(`æŒ‰è§’è‰²: ${Object.entries(stats.byRole).map(([role, count]) => `${role}:${count}`).join(', ')}`);
            console.log(`æ•ˆç‡: ${Object.entries(stats.efficiency).map(([role, eff]) => `${role}:${eff.toFixed(1)}%`).join(', ')}`);
        }
    }
}

// å…¨å±€å®ä¾‹
export const creepManager = CreepManager.getInstance(); 